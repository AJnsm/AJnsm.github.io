---
layout: post
title:  "Compositionally sharing pie"
date:   2022-11-25 10:00:00 +0200
author: Abel Jansma
tags: ethereum maths category-theory cybernetics
---
<span style="color:grey">(This is an update on my Ethereum Protocol Fellowship. More updates can be found [here]({% post_url 2022-10-18-EPF0 %}) ).</span>

<br>


I wanted to make the pie sharing game compositional so that I could model n players sharing the pie. I already had the 2-player game, so 'opening up' that game would be a logical first attempt. That would create an open game with two players, Player 1 offering a cut pie to Player 2, and Player 2 choosing one of the pieces (or equivalently: Player 1 offering a piece of the pie, and Player 2 deciding to either accept the offered piece, of choose the rest of the pie). This could be opened up by letting Player 1 start with an offered piece of pie, instead of the full pie, and choosing to accept it or not, before confronting Player 2 with the same choice, based on a cut from the piece Player 1 chose. This looks something like this:

<br>

![](/assets/img_EPF/openPies_level1.png)

<br>

However, since each player is on equal footing, it does not really make sense to have the fundamental game be a 2-player game of two identical players. In fact, the reason I like this setup is because this game *very naturally* fills all arrows of an open game. Each player is confronted with an offer, responds with a choice that serves as feedback to the previous player (and determines that previous player's payoff), and presents an offer to the next player, who will respond with similar feedback. This looks like the quintessential open game:


<br>

![](/assets/img_EPF/openPies_level2.png)

<br>

While this might be a natural way to implement this game, it relies on a dependent decision that send part of the decision (the response) to the feedback channel, and part of the decision (the new offer) to the output. This is practically hard to model. Instead, I zoomed in even more, and realised that each player actually performs two separate actions: responding to the previous player's offer, and presenting a new offer. This can be separated, to create a situation like this, in which there are two different fundamental games:

<br>

![](/assets/img_EPF/openPies_level3.png)

<br>

This last option has the drawback that it uses two different fundamental games, but this also allows us to change either game independently. Furthermore, the 'Respond' game has implicit feedback by using the cup, but no return, and the 'Cut' game has a return, but no feedback. This makes both much simpler decision games. 

To implement this compositional structure, first define the relevant types and the payoff function:

<br>


```haskell
type Offer = Double

data ResponderAction = Accept | Reject
  deriving (Eq,Ord,Show)

openPieSharingGamePayoff ::  Offer -> Offer -> ResponderAction -> Payoff
openPieSharingGamePayoff offer newOffer response =
    if response == Accept then (offer - newOffer) else newOffer
```

<br>

The 'Respond' game is then implemented as the following:

<br>


```haskell
respondToOffer playerName = [opengame|

   inputs    : offer  ;
   feedback  : response;

   :----------------------------:
   inputs    : offer  ;
   feedback  : ;
   operation : dependentDecision playerName (const [Accept,Reject]) ;
   outputs   : response ;
   returns   : 0;
   // Postpone payoff calculation, so here just return a payoff of 0. 

   :----------------------------:

   outputs   : (offer, response) ;
   returns   : ;
   |]
```

<br>

And the 'Cut' game that offers a new slice to the next player is defined as:

<br>


```haskell
offerNewSlice playerName = [opengame|

   inputs    : (offer, response)  ;
   feedback  : ;

   :----------------------------:
   inputs    : (offer, response)  ;
   feedback  : ;
   operation : dependentDecision playerName (\(x, y) -> [0..x]) ;
   outputs   : newOffer ;
   returns   : openPieSharingGamePayoff offer newOffer newResponse ;
   :----------------------------:

   outputs   : newOffer ;
   returns   : newResponse;
   |]
```

<br>


The two are then composed into the fundamental unit of the compositional pie sharing game:

<br>


```haskell
openPieSharing_unit playerName = [opengame|

   inputs    : inputOffer  ;
   feedback  : inputResponse;

   :----------------------------:
   inputs    : inputOffer  ;
   feedback  : inputResponse;
   operation : respondToOffer playerName ;
   outputs   : (offer, response) ;
   returns   : ;


   inputs    : (offer, response)  ;
   feedback  : ;
   operation : offerNewSlice playerName ;
   outputs   : newOffer   ;
   returns   : newResponse;

   :----------------------------:

   outputs   : newOffer   ;
   returns   : newResponse;
   |]
```

<br>

At this point, I had only analysed games in a trivial context (void), so to analyse this game, I created a 'closure' game that add (co)point games to make the full game trivial:

<br>


```haskell

pieSharingModule_closure pieSize = [opengame|

   inputs    :  ;
   feedback  :  ;

   :---------------------------:

   inputs:    ;
   feedback:  ;
   operation: dependentDecision "inputState" (const lsPie);
   outputs: defaultOffer;
   returns: 0;


   inputs    : defaultOffer ;
   feedback  : nullResponse ;
   operation : openPieSharing_unit "player1";
   outputs   : offer ;
   returns   : nextResponse;

   inputs:    offer;
   feedback:  ;
   operation: dependentDecision "continuationState" (const lsAccept);
   outputs: nextResponse;
   returns: 0;

   :----------------------------:
   outputs   :  ;
   returns   :  ;
   |]
  where 
    lsPie = [pieSize]
    lsAccept = [Accept]
```

<br>

Creating such closure games is not generally a nice way to do the analysis, as covered in the [FAQ]({% post_url 2022-11-25-EPF-FAQ %}). The reason that the constant actionspace has to be defined outside of the Open Game Engine DSL is a parser bug, described in more detail [here](https://github.com/jules-hedges/open-games-hs/issues/17). 

Therefore, instead of using this closure game, I constructed a context called `contextContPie` for the open `openPieSharing_unit` game that inputs a full pie size, and always accepts the offer made by the open game:

<br>


```haskell
contextContPie :: Double -> StochasticStatefulContext
          Double
          Examples.PieCutting_open.ResponderAction
          Double
          Examples.PieCutting_open.ResponderAction

contextContPie fullPieSize = StochasticStatefulContext (pure ((),fullPieSize)) (\_ _ -> pure Accept)
```

<br>

In this context, a strategy `strat` can be analysed using the following functions:

<br>


```haskell
evalOpenPie strat = evaluate (openPieSharing_unit "p1") strat (contextContPie 10)
isEquilibriumPieSharingGameOpen strat = generateIsEq $ evalOpenPie strat 
```

<br>

Finally, we need to provide the actual strategies a player can have. Note that this is a single player that needs to make two different decisions: which piece to pick, and what to offer the next player. I'm not actually sure how to best implement such a dual strategy. However, the necessary type can be seen by running the following:

<br>


```haskell
λ: :t isEquilibriumPieSharingGameOpen
isEquilibriumPieSharingGameOpen
  :: List [Kleisli Stochastic Double ResponderAction,
         Kleisli Stochastic (Double, ResponderAction) Double]
     -> IO ()
```

<br>

Which indeed matches what one would expect. I constructed a strategy that always accepts the incoming offer, but only offers a pie size of 2:

<br>


```haskell
selfishStrat_PieSharingOpen :: List [Kleisli Stochastic Double ResponderAction,
         Kleisli Stochastic (Double, ResponderAction) Double]
selfishStrat_PieSharingOpen = Kleisli pureAccept ::- Kleisli smallOffer ::- Nil
    where 
        pureAccept x = playDeterministically Accept
        smallOffer (x, y) = playDeterministically 2
```

<br>

This allows us to analyse the final game. The equilibrium analysis gives the expected conclusion: in a context of a pie of size 10, and that always accepts any offer that the player makes, being greedy is good---while offering 2 is already a bit stingy, it's even better to offer nothing at all:

<br>


```haskell
λ: isEquilibriumPieSharingGameOpen selfishStrat_PieSharingOpen
```
```
----Analytics begin----
 Strategies are in equilibrium
 NEWGAME: 

 Strategies are NOT in equilibrium. Consider the following profitable deviations: 

Player: p1
Optimal Move: 0.0
Current Strategy: fromFreqs [(2.0,1.0)]
Optimal Payoff: 10.0
Current Payoff: 8.0
Observable State: (10.0,Accept)
Unobservable State: "(((),(10.0,(10.0,Accept))),(10.0,Accept))"
 --other game-- 
 --No more information--
 NEWGAME: 
----Analytics end----
```

<br>

This open game can now *very* easily be composed into bigger games. Keeping the strategy and the context the same for now, I define the following game and functions:

<br>


```haskell

openPieSharing_twoPlayers = [opengame|

   inputs    : inputOffer  ;
   feedback  : inputResponse;

   :----------------------------:
   inputs    : inputOffer  ;
   feedback  : inputResponse;
   operation : openPieSharing_unit "p1" ;
   outputs   : newOffer1   ;
   returns   : newResponse1 ;

   inputs    : newOffer1  ;
   feedback  : newResponse1 ;
   operation : openPieSharing_unit "p2" ;
   outputs   : newOffer2   ;
   returns   : newResponse2 ;
   
   :----------------------------:

   outputs   : newOffer2   ;
   returns   : newResponse2 ;
   |]


combinedStrat  = selfishStrat_PieSharingOpen ::- selfishStrat_PieSharingOpen ::- Nil
evalOpenPie_twoPlayers strat = evaluate (openPieSharing_twoPlayers) strat (contextContPie 10)
isEquilibriumPieSharingGameOpen_twoPlayers strat = generateIsEq $ evalOpenPie_twoPlayers strat 
```

<br>

Unfortunately, this results in the following type error:

<br>


```haskell
λ: isEquilibriumPieSharingGameOpen_twoPlayers combinedStrat

<interactive>:43:44: error:
    • Couldn't match type ‘List
                             '[Kleisli
                                 Stochastic Double ResponderAction,
                               Kleisli
                                 Stochastic
                                 (Double, ResponderAction)
                                 Double]’
                     with ‘Kleisli
                             Stochastic Double ResponderAction’
      Expected type: List
                       '[Kleisli
                           Stochastic Double ResponderAction,
                         Kleisli
                           Stochastic
                           (Double, ResponderAction)
                           Double,
                         Kleisli Stochastic Double ResponderAction,
                         Kleisli
                           Stochastic
                           (Double, ResponderAction)
                           Double]
        Actual type: List
                       '[List
                           '[Kleisli
                               Stochastic Double ResponderAction,
                             Kleisli
                               Stochastic
                               (Double, ResponderAction)
                               Double],
                         List
                           '[Kleisli
                               Stochastic Double ResponderAction,
                             Kleisli
                               Stochastic
                               (Double, ResponderAction)
                               Double]]
    • In the first argument of ‘isEquilibriumPieSharingGameOpen_twoPlayers’, namely
        ‘combinedStrat’
      In the expression:
        isEquilibriumPieSharingGameOpen_twoPlayers combinedStrat
      In an equation for ‘it’:
          it = isEquilibriumPieSharingGameOpen_twoPlayers combinedStrat
```

<br>

Since each player has a list of strategies, the combined list of strategies is now nested, which triggers the type error. This is an indication that the way I currently construct the strategy profiles for each player is not the best way. One option is to flatten the final list of strategy profiles, but a simple `concat combinedStrat` did not solve the problem. 